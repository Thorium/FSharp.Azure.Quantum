# Phase 4: Idiomatic F# Data Loading Consolidation

## Overview

Phase 4 consolidates the chemistry data import/export functionality into a single, idiomatic F# module in the Data layer. This eliminates code duplication between `QuantumChemistry.MolecularInput` and `ChemistryDataProviders` while providing a cleaner, more composable API.

## Design Philosophy: Small Data, Big Compute

**Quantum chemistry workloads are computation-bound, not I/O-bound.**

When properly scoped for quantum computing (small molecules, minimal basis sets, active space selection), datasets are tiny:
- Tens of atoms, not thousands
- Kilobytes of geometry data
- The real work is in integrals, Hamiltonians, and VQE/QPE circuits

Therefore, this design prioritizes:
- **Correctness** over caching complexity
- **Simplicity** over async batch optimization  
- **Readability** over micro-performance
- **Composability** over framework abstractions

We keep async for file I/O (good practice), but don't over-engineer caching layers or parallel loading for datasets that fit in a single string.

## Problem Statement

Currently, molecule file parsing exists in **two places**:

| Location | Functions | Issue |
|----------|-----------|-------|
| `QuantumChemistry.MolecularInput` | `fromXYZAsync`, `fromFCIDumpAsync`, `toXYZ`, `saveXYZAsync` | Duplicates parsing logic in solver code |
| `ChemistryDataProviders.XyzImporter` | `fromFileAsync`, `toXyz`, `saveToFileAsync` | The "correct" location, but not all callers use it |
| `ChemistryDataProviders.FciDumpParser` | `parseHeader`, `parseFile` | Header-only parsing |

The duplication causes:
1. **Maintenance burden** - Bug fixes needed in multiple places
2. **Inconsistent behavior** - Subtle differences in parsing logic
3. **Wrong layer** - File I/O doesn't belong in solver code
4. **Non-idiomatic API** - Mixed sync/async, class-heavy design

## Design Goals

1. **Single source of truth** for each file format parser
2. **Idiomatic F#** - module functions, composition, railway-oriented
3. **Separation of concerns** - Data layer owns I/O, Solver layer consumes domain types
4. **Deprecate without breaking** - Add `[<Obsolete>]` to old APIs, keep them working

---

## Proposed Architecture

### Module Structure

```
FSharp.Azure.Quantum.Data/
├── MoleculeFormats.fs          # NEW: Unified format parsing
│   ├── Xyz module              # XYZ format (read/write)
│   ├── FciDump module          # FCIDump format (read-only header)
│   ├── Sdf module              # SDF/MOL format (read/write)
│   └── Pdb module              # PDB ligand extraction
│
├── ChemistryDataProviders.fs   # Existing: Provider implementations
│   ├── Dataset providers       # Use MoleculeFormats internally
│   └── Remove duplicate parsers
│
└── [Other existing files unchanged]
```

### Core Abstraction: Simple Functions

No complex abstractions needed. Each format module exposes:

```fsharp
module MoleculeFormats =
    
    module Xyz =
        /// Pure parsing: string -> Result
        val parse: content:string -> QuantumResult<MoleculeInstance>
        
        /// File I/O (async for non-blocking, but no parallelism needed)
        val readAsync: path:string -> Async<QuantumResult<MoleculeInstance>>
        
        /// Pure formatting: instance -> string  
        val format: mol:MoleculeInstance -> string
        
        /// File I/O
        val writeAsync: path:string -> mol:MoleculeInstance -> Async<QuantumResult<unit>>
```

The pattern is consistent:
- **`parse`**: Pure function, content → Result (easy to test)
- **`readAsync`**: File → parse (thin I/O wrapper)
- **`format`**: Pure function, instance → string
- **`writeAsync`**: format → File (thin I/O wrapper)

### Format Modules

Each format gets a dedicated module with consistent API:

```fsharp
module Xyz =
    /// Parse XYZ content string
    val parse: string -> ParseResult
    
    /// Read XYZ file asynchronously
    val readAsync: string -> Async<ParseResult>
    
    /// Format molecule as XYZ string
    val format: MoleculeInstance -> string
    
    /// Write molecule to XYZ file asynchronously  
    val writeAsync: string -> MoleculeInstance -> Async<QuantumResult<unit>>

module FciDump =
    /// Parse FCIDump header from content
    val parseHeader: string -> QuantumResult<FciDumpHeader>
    
    /// Read FCIDump file (header only, geometry = None)
    val readAsync: string -> Async<ParseResult>
    
    // No write support - FCIDump is generated by QC software

module Sdf =
    /// Parse SDF content (may contain multiple molecules)
    val parseAll: string -> QuantumResult<MoleculeInstance array>
    
    /// Parse single MOL block
    val parseMol: string -> ParseResult
    
    /// Read SDF file
    val readAsync: string -> Async<QuantumResult<MoleculeInstance array>>
    
    /// Format molecules as SDF string
    val formatAll: MoleculeInstance array -> string
    
    /// Write molecules to SDF file
    val writeAsync: string -> MoleculeInstance array -> Async<QuantumResult<unit>>

module Pdb =
    /// Parse PDB content and extract ligands (HETATM records)
    val parseLigands: string -> QuantumResult<MoleculeInstance array>
    
    /// Read PDB file and extract ligands
    val readLigandsAsync: string -> Async<QuantumResult<MoleculeInstance array>>
```

### Composition with Active Patterns

For format detection, use active patterns:

```fsharp
module FormatDetection =
    
    /// Detect format from file extension
    let (|XyzFile|SdfFile|MolFile|PdbFile|FciDumpFile|UnknownFile|) (path: string) =
        match Path.GetExtension(path).ToLowerInvariant() with
        | ".xyz" -> XyzFile
        | ".sdf" -> SdfFile
        | ".mol" -> MolFile
        | ".pdb" | ".ent" -> PdbFile
        | ".fcidump" | ".FCIDUMP" -> FciDumpFile
        | _ -> UnknownFile (Path.GetExtension path)
    
    /// Read molecule(s) from file, auto-detecting format
    let readAutoAsync (path: string) : Async<QuantumResult<MoleculeInstance array>> =
        async {
            match path with
            | XyzFile -> 
                let! result = Xyz.readAsync path
                return result |> Result.map Array.singleton
            | SdfFile | MolFile ->
                return! Sdf.readAsync path
            | PdbFile ->
                return! Pdb.readLigandsAsync path
            | FciDumpFile ->
                let! result = FciDump.readAsync path
                return result |> Result.map Array.singleton
            | UnknownFile ext ->
                return Error (QuantumError.ValidationError("FileFormat", $"Unknown file extension: {ext}"))
        }
```

---

## Implementation Details

### XYZ Module (Consolidating Duplicates)

The new `Xyz` module consolidates:
- `QuantumChemistry.MolecularInput.fromXYZAsync` 
- `ChemistryDataProviders.XyzImporter.fromFileAsync`

Key changes:
1. Single parsing function used by both file and content readers
2. Consistent bond inference using `PeriodicTable.estimateBondLength`
3. Proper error messages with line numbers

```fsharp
module Xyz =
    
    /// Parse atom line: "Element X Y Z"
    let private parseAtomLine (lineNum: int) (line: string) : QuantumResult<string * AtomGeometry> =
        let parts = line.Split([|' '; '\t'|], StringSplitOptions.RemoveEmptyEntries)
        if parts.Length < 4 then
            Error (QuantumError.ValidationError("XyzLine", $"Line {lineNum}: Expected 'Element X Y Z'"))
        else
            let element = parts.[0].Trim()
            match Double.TryParse(parts.[1], NumberStyles.Float, CultureInfo.InvariantCulture),
                  Double.TryParse(parts.[2], NumberStyles.Float, CultureInfo.InvariantCulture),
                  Double.TryParse(parts.[3], NumberStyles.Float, CultureInfo.InvariantCulture) with
            | (true, x), (true, y), (true, z) ->
                if PeriodicTable.isValidSymbol element then
                    Ok (element, { X = x; Y = y; Z = z })
                else
                    Error (QuantumError.ValidationError("Element", $"Line {lineNum}: Unknown element '{element}'"))
            | _ ->
                Error (QuantumError.ValidationError("XyzLine", $"Line {lineNum}: Invalid coordinates"))
    
    /// Infer bonds from geometry using covalent radii
    let private inferBonds (atoms: (string * AtomGeometry) array) : (int * int * float option) array =
        [| for i in 0 .. atoms.Length - 2 do
               for j in i + 1 .. atoms.Length - 1 do
                   let (elem1, coord1), (elem2, coord2) = atoms.[i], atoms.[j]
                   let dx, dy, dz = coord2.X - coord1.X, coord2.Y - coord1.Y, coord2.Z - coord1.Z
                   let distance = sqrt (dx*dx + dy*dy + dz*dz)
                   match PeriodicTable.estimateBondLength elem1 elem2 with
                   | Some expected when distance <= expected * 1.25 ->
                       yield (i, j, Some 1.0)
                   | None when distance < 3.0 ->
                       yield (i, j, Some 1.0)  // Fallback heuristic
                   | _ -> () |]
    
    /// Parse XYZ content string
    let parse (content: string) : ParseResult =
        let lines = 
            content.Split([|'\n'; '\r'|], StringSplitOptions.RemoveEmptyEntries)
            |> Array.map (fun s -> s.Trim())
            |> Array.filter (String.IsNullOrWhiteSpace >> not)
        
        result {
            do! if lines.Length < 3 then
                    Error (QuantumError.ValidationError("XyzFile", "Need at least 3 lines"))
                else Ok ()
            
            let! atomCount =
                match Int32.TryParse lines.[0] with
                | true, n when n > 0 -> Ok n
                | _ -> Error (QuantumError.ValidationError("XyzFile", "First line must be positive atom count"))
            
            do! if lines.Length < 2 + atomCount then
                    Error (QuantumError.ValidationError("XyzFile", $"Expected {atomCount} atoms, file too short"))
                else Ok ()
            
            let name = lines.[1]
            
            let! atomsWithCoords =
                lines.[2 .. 1 + atomCount]
                |> Array.mapi (fun i line -> parseAtomLine (i + 3) line)
                |> Array.fold (fun acc r ->
                    match acc, r with
                    | Error e, _ | _, Error e -> Error e
                    | Ok list, Ok atom -> Ok (atom :: list)
                ) (Ok [])
                |> Result.map (List.rev >> List.toArray)
            
            let bonds = inferBonds atomsWithCoords
            
            return {
                Id = if String.IsNullOrWhiteSpace name then None else Some name
                Name = if String.IsNullOrWhiteSpace name then None else Some name
                Topology = {
                    Atoms = atomsWithCoords |> Array.map fst
                    Bonds = bonds
                    Charge = None
                    Multiplicity = None
                    Metadata = Map.ofList ["source_format", "xyz"]
                }
                Geometry = Some {
                    Coordinates = atomsWithCoords |> Array.map snd
                    Units = "angstrom"
                }
            }
        }
    
    /// Read XYZ file asynchronously
    let readAsync (path: string) : Async<ParseResult> =
        async {
            try
                if not (File.Exists path) then
                    return Error (QuantumError.IOError("ReadXYZ", path, "File not found"))
                else
                    let! content = File.ReadAllTextAsync(path) |> Async.AwaitTask
                    return parse content
            with ex ->
                return Error (QuantumError.OperationError("XyzRead", ex.Message))
        }
    
    /// Format molecule as XYZ string
    let format (mol: MoleculeInstance) : string =
        match mol.Geometry with
        | None -> failwith "Cannot format molecule without geometry as XYZ"
        | Some geom ->
            let sb = StringBuilder()
            sb.AppendLine(string mol.Topology.Atoms.Length) |> ignore
            sb.AppendLine(mol.Name |> Option.defaultValue "Molecule") |> ignore
            for i, elem in mol.Topology.Atoms |> Array.indexed do
                let c = geom.Coordinates.[i]
                sb.AppendLine(String.Format(CultureInfo.InvariantCulture, 
                    "{0,-2}  {1,10:F6}  {2,10:F6}  {3,10:F6}", elem, c.X, c.Y, c.Z)) |> ignore
            sb.ToString()
    
    /// Write molecule to XYZ file
    let writeAsync (path: string) (mol: MoleculeInstance) : Async<QuantumResult<unit>> =
        async {
            try
                let content = format mol
                do! File.WriteAllTextAsync(path, content) |> Async.AwaitTask
                return Ok ()
            with ex ->
                return Error (QuantumError.IOError("WriteXYZ", path, ex.Message))
        }
```

### Deprecation of `MolecularInput`

Add deprecation notices to existing functions:

```fsharp
module MolecularInput =
    
    [<Obsolete("Use MoleculeFormats.Xyz.readAsync instead. This function will be removed in v3.0.")>]
    let fromXYZAsync (filePath: string) : Async<Result<Molecule, QuantumError>> =
        async {
            let! result = MoleculeFormats.Xyz.readAsync filePath
            return result |> Result.bind (fun instance ->
                match Molecule.fromInstance instance with
                | Some mol -> Ok mol
                | None -> Error (QuantumError.ValidationError("Conversion", "Failed to convert to Molecule"))
            )
        }
    
    [<Obsolete("Use MoleculeFormats.FciDump.readAsync instead. This function will be removed in v3.0.")>]
    let fromFCIDumpAsync (filePath: string) : Async<Result<Molecule, QuantumError>> =
        // Delegate to new implementation
        ...
    
    [<Obsolete("Use MoleculeFormats.Xyz.format instead. This function will be removed in v3.0.")>]
    let toXYZ (molecule: Molecule) : string =
        let instance = Molecule.toInstance molecule
        MoleculeFormats.Xyz.format instance
    
    [<Obsolete("Use MoleculeFormats.Xyz.writeAsync instead. This function will be removed in v3.0.")>]
    let saveXYZAsync (filePath: string) (molecule: Molecule) : Async<Result<unit, QuantumError>> =
        let instance = Molecule.toInstance molecule
        MoleculeFormats.Xyz.writeAsync filePath instance
```

---

## Provider Simplification

With format parsing in dedicated modules, providers become thin wrappers.

**Note**: For QC workloads, the `CachingDatasetProvider` is rarely needed - molecules are small and parsed once. Keep it available for DrugDiscovery/ML screening workflows where you might load thousands of SMILES, but don't complicate the core QC path.

```fsharp
type XyzFileDatasetProvider(directory: string) =
    
    interface IMoleculeDatasetProviderAsync with
        
        member _.LoadAsync(query) =
            async {
                match query with
                | ByPath path ->
                    let! result = MoleculeFormats.Xyz.readAsync path
                    return result |> Result.map (fun mol ->
                        { Molecules = [| mol |]
                          Labels = None
                          LabelColumn = None
                          Metadata = Map.ofList ["source", path] })
                
                | ByName name ->
                    let path = Path.Combine(directory, name + ".xyz")
                    return! (this :> IMoleculeDatasetProviderAsync).LoadAsync(ByPath path)
                
                | All ->
                    // Sequential is fine - we're loading a handful of small files
                    let files = Directory.GetFiles(directory, "*.xyz")
                    let! results = 
                        files 
                        |> Array.map MoleculeFormats.Xyz.readAsync 
                        |> Async.Sequential  // Not Parallel - simplicity over micro-perf
                    let molecules = results |> Array.choose Result.toOption
                    return Ok { Molecules = molecules; Labels = None; LabelColumn = None
                                Metadata = Map.ofList ["source", directory] }
                
                | ByCategory _ ->
                    return Error (QuantumError.ValidationError("UnsupportedQuery", "XYZ provider doesn't support categories"))
            }
```

---

## Conversion Between Types

### `Molecule` <-> `MoleculeInstance`

Add conversion functions to bridge solver and data layer types:

```fsharp
module Molecule =
    
    /// Convert solver Molecule to data layer MoleculeInstance
    let toInstance (mol: Molecule) : MoleculeInstance =
        let topology = {
            Atoms = mol.Atoms |> List.map (fun a -> a.Element) |> List.toArray
            Bonds = mol.Bonds |> List.map (fun b -> (b.Atom1, b.Atom2, Some b.BondOrder)) |> List.toArray
            Charge = Some mol.Charge
            Multiplicity = Some mol.Multiplicity
            Metadata = Map.empty
        }
        let geometry = {
            Coordinates = 
                mol.Atoms 
                |> List.map (fun a -> let (x,y,z) = a.Position in { X=x; Y=y; Z=z })
                |> List.toArray
            Units = "angstrom"
        }
        { Id = Some mol.Name
          Name = Some mol.Name
          Topology = topology
          Geometry = Some geometry }
    
    /// Convert data layer MoleculeInstance to solver Molecule
    let fromInstance (inst: MoleculeInstance) : Molecule option =
        inst.Geometry |> Option.map (fun geom ->
            let atoms =
                Array.zip inst.Topology.Atoms geom.Coordinates
                |> Array.map (fun (elem, c) -> { Element = elem; Position = (c.X, c.Y, c.Z) })
                |> Array.toList
            let bonds =
                inst.Topology.Bonds
                |> Array.map (fun (a1, a2, order) -> 
                    { Atom1 = a1; Atom2 = a2; BondOrder = order |> Option.defaultValue 1.0 })
                |> Array.toList
            { Name = inst.Name |> Option.defaultValue "Molecule"
              Atoms = atoms
              Bonds = bonds
              Charge = inst.Topology.Charge |> Option.defaultValue 0
              Multiplicity = inst.Topology.Multiplicity |> Option.defaultValue 1 }
        )
```

---

## Migration Checklist

### Phase 4a: Create `MoleculeFormats.fs` (non-breaking)

- [ ] Create new `MoleculeFormats.fs` file in Data layer
- [ ] Implement `Xyz` module with parse/read/format/write
- [x] Implement `FciDump` module with parseHeader/read
- [x] Implement `Sdf` module delegating to existing `SdfMolParser`
- [x] Implement `Pdb` module delegating to existing `PdbParser`
- [x] Add `FormatDetection` with active patterns
- [x] Add unit tests for all format modules

### Phase 4b: Wire up providers (non-breaking)

- [x] Update `XyzFileDatasetProvider` to use `MoleculeFormats.Xyz`
- [x] Update `SdfFileDatasetProvider` to use `MoleculeFormats.Sdf`
- [x] Update `FciDumpFileDatasetProvider` to use `MoleculeFormats.FciDump`
- [x] Update `PdbLigandDatasetProvider` to use `MoleculeFormats.Pdb`
- [x] Remove duplicate parser code from `ChemistryDataProviders.fs`

### Phase 4c: Deprecate old APIs (non-breaking) - SKIPPED

> **Note**: Phase 4c was skipped. We went directly from Phase 4b to 4d since:
> - All internal code was already migrated to use MoleculeFormats
> - No external consumers yet (pre-release library)
> - Deprecation + removal in same release cycle adds no value

### Phase 4d: v3.0 removal (breaking) - COMPLETE

- [x] Remove `MolecularInput` module entirely
- [x] Remove legacy sync wrappers
- [x] Update all internal callers
- [x] Add `Molecule.fromXyzFileAsync/fromXyzFile` convenience functions
- [x] Add `Molecule.fromFciDumpFileAsync/fromFciDumpFile` convenience functions  
- [x] Add `Molecule.toXyz` and `Molecule.saveToXyzFileAsync/saveToXyzFile` functions
- [x] Update C# extensions to use new Molecule.* functions
- [x] Update all tests to use new APIs

---

## API Summary

### Before (scattered, duplicated) - REMOVED

```fsharp
// REMOVED: Was in QuantumChemistry.fs (solver layer - wrong place for I/O)
MolecularInput.fromXYZAsync path       // -> Use Molecule.fromXyzFileAsync
MolecularInput.fromFCIDumpAsync path   // -> Use Molecule.fromFciDumpFileAsync
MolecularInput.toXYZ molecule          // -> Use Molecule.toXyz
MolecularInput.saveXYZAsync path mol   // -> Use Molecule.saveToXyzFileAsync

// REMOVED: Was in ChemistryDataProviders.fs (class-heavy)
XyzImporter.fromFileAsync path         // -> Use MoleculeFormats.Xyz.readAsync
XyzImporter.toXyz molecule             // -> Use MoleculeFormats.Xyz.format
XyzImporter.saveToFileAsync path mol   // -> Use MoleculeFormats.Xyz.writeAsync
SdfMolParser.parseSdfFile content      // -> Use MoleculeFormats.Sdf.parseAll
FciDumpParser.parseFile path           // -> Use MoleculeFormats.FciDump.readAsync
PdbParser.parseFile content            // -> Use MoleculeFormats.Pdb.parseLigands
```

### After (unified, idiomatic)

```fsharp
// Low-level format I/O - MoleculeFormats module (Data layer)
MoleculeFormats.Xyz.readAsync path       // MoleculeData
MoleculeFormats.Xyz.parse content        // MoleculeData
MoleculeFormats.Xyz.format data          // string
MoleculeFormats.Xyz.writeAsync path data // unit

MoleculeFormats.FciDump.readAsync path   // FciDumpHeader
MoleculeFormats.FciDump.parseHeader s    // FciDumpHeader

MoleculeFormats.Sdf.readAsync path       // MoleculeData list
MoleculeFormats.Sdf.parseAll content     // MoleculeData list

MoleculeFormats.Pdb.readLigandsAsync path  // MoleculeData list
MoleculeFormats.Pdb.parseLigands content   // MoleculeData list

// High-level convenience - Molecule module (QC layer)
Molecule.fromXyzFileAsync path           // Result<Molecule,string>
Molecule.fromFciDumpFileAsync path       // Result<Molecule,string>
Molecule.toXyz molecule                  // string
Molecule.saveToXyzFileAsync path mol     // Async<unit>
```

---

## Benefits

1. **Single source of truth** - Each format parsed in one place
2. **Idiomatic F#** - Module functions, not classes with interfaces
3. **Composable** - Functions can be piped, partial applied
4. **Testable** - Pure `parse` functions easy to unit test
5. **Discoverable** - `MoleculeFormats.Xyz.` shows all XYZ operations
6. **Consistent** - Same API shape for all formats
7. **Proper layering** - I/O in Data layer, Solver layer consumes domain types
8. **Right-sized complexity** - No over-engineering for small data workloads
