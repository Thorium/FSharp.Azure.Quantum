Build started 27/11/2025 18:31:04.
     1>Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\FSharp.Azure.Quantum.sln" on node 1 (Restore target(s)).
     1>ValidateSolutionConfiguration:
         Building solution configuration "Debug|Any CPU".
       _GetAllRestoreProjectPathItems:
         Determining projects to restore...
     1>Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\FSharp.Azure.Quantum.sln" (1) is building "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\src\FSharp.Azure.Quantum\FSharp.Azure.Quantum.fsproj" (2:6) on node 1 (_GenerateProjectRestoreGraph target(s)).
     2>AddPrunePackageReferences:
         Loading prune package data from PrunePackageData folder
         Failed to load prune package data from PrunePackageData folder, loading from targeting packs instead
     1>Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\FSharp.Azure.Quantum.sln" (1) is building "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (3:5) on node 2 (_GenerateProjectRestoreGraph target(s)).
     3>AddPrunePackageReferences:
         Loading prune package data from PrunePackageData folder
         Failed to load prune package data from PrunePackageData folder, loading from targeting packs instead
         Looking for targeting packs in C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref
         Pack directories found: C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\10.0.0
         Found package overrides file C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\10.0.0\data\PackageOverrides.txt
     2>AddPrunePackageReferences:
         Looking for targeting packs in C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref
         Pack directories found: C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\10.0.0
     3>Done Building Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (_GenerateProjectRestoreGraph target(s)).
     2>AddPrunePackageReferences:
         Found package overrides file C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\10.0.0\data\PackageOverrides.txt
     2>Done Building Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\src\FSharp.Azure.Quantum\FSharp.Azure.Quantum.fsproj" (_GenerateProjectRestoreGraph target(s)).
     1>Restore:
         X.509 certificate chain validation will use the default trust store selected by .NET for code signing.
         X.509 certificate chain validation will use the default trust store selected by .NET for timestamping.
         Assets file has not changed. Skipping assets file writing. Path: C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\obj\project.assets.json
         Assets file has not changed. Skipping assets file writing. Path: C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\src\FSharp.Azure.Quantum\obj\project.assets.json
         Restored C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj (in 38 ms).
         Restored C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\src\FSharp.Azure.Quantum\FSharp.Azure.Quantum.fsproj (in 38 ms).
         
         NuGet Config files used:
             C:\Users\thori\AppData\Roaming\NuGet\NuGet.Config
             C:\Program Files (x86)\NuGet\Config\Microsoft.VisualStudio.FallbackLocation.config
             C:\Program Files (x86)\NuGet\Config\Microsoft.VisualStudio.Offline.config
         
         Feeds used:
             https://api.nuget.org/v3/index.json
             C:\Program Files (x86)\Microsoft SDKs\NuGetPackages\
             C:\Program Files\dotnet\library-packs
             C:\Program Files\dotnet\sdk\10.0.100\FSharp\library-packs
         All projects are up-to-date for restore.
     1>Done Building Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\FSharp.Azure.Quantum.sln" (Restore target(s)).
   1:2>Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\FSharp.Azure.Quantum.sln" on node 1 (VSTest target(s)).
     1>ValidateSolutionConfiguration:
         Building solution configuration "Debug|Any CPU".
   1:2>Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\FSharp.Azure.Quantum.sln" (1:2) is building "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (3:6) on node 2 (VSTest target(s)).
     3>BuildProject:
         Build started, please wait...
   3:6>Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (3:6) is building "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (3:7) on node 2 (default targets).
   3:7>Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (3:7) is building "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\src\FSharp.Azure.Quantum\FSharp.Azure.Quantum.fsproj" (2:9) on node 1 (default targets).
     2>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       _GenerateSourceLinkFile:
         Source Link file 'obj\Debug\net10.0\FSharp.Azure.Quantum.sourcelink.json' is up-to-date.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         FSharp.Azure.Quantum -> C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\src\FSharp.Azure.Quantum\bin\Debug\net10.0\FSharp.Azure.Quantum.dll
     2>Done Building Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\src\FSharp.Azure.Quantum\FSharp.Azure.Quantum.fsproj" (default targets).
     3>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       _GenerateSourceLinkFile:
         Source Link file 'obj\Debug\net10.0\FSharp.Azure.Quantum.Tests.sourcelink.json' is up-to-date.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildRuntimeConfigurationFiles:
       Skipping target "GenerateBuildRuntimeConfigurationFiles" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         FSharp.Azure.Quantum.Tests -> C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\bin\Debug\net10.0\FSharp.Azure.Quantum.Tests.dll
     3>Done Building Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (default targets).
     3>BuildProject:
         Build completed.
         
Test run for C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\bin\Debug\net10.0\FSharp.Azure.Quantum.Tests.dll (.NETCoreApp,Version=v10.0)
VSTest version 18.0.1 (x64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.
[xUnit.net 00:00:00.00] xUnit.net VSTest Adapter v3.1.4+50e68bbb8b (64-bit .NET 10.0.0)
[xUnit.net 00:00:00.43]   Discovering: FSharp.Azure.Quantum.Tests
[xUnit.net 00:00:00.48]   Discovered:  FSharp.Azure.Quantum.Tests
[xUnit.net 00:00:00.51]   Starting:    FSharp.Azure.Quantum.Tests
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply cost layer - should apply Rz rotations [122 ms]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.RateLimiter shouldThrottle returns false when plenty of requests remain [127 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CNOT gate - should work with different qubit orderings [125 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Measure computational basis - should return valid outcome [130 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeTwoQubitGate should produce 16-term decomposition [131 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate X should have correct qubit [131 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator should handle concurrent adds safely [133 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CNOT gate - should flip target when control is 1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.withCalibrationShots should override calibration shots [136 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get most likely outcome - should return highest probability state [1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Complex rotation composition - should produce correct final state [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply cost layer - should handle zero coefficients [3 ms]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.RateLimitInfo should store remaining requests, limit, and reset time [3 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Pauli-Y gate - should apply Y rotation correctly [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Medium circuit (25 gates) with budget should select ZNE + Readout [141 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Compute cost expectation - should handle superposition [4 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Full QAOA workflow - should optimize simple problem [1 ms]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.parseRateLimitHeaders should extract rate limit info from HTTP headers [6 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Compute cost expectation - should reject mismatched array length [1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Gate validation - should reject invalid qubit indices [6 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Ry gate - should rotate around Y axis correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Full measurement workflow - simulate and analyze [10 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply QAOA layer - should combine cost and mixer [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Compute cost expectation - should handle multiple qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CNOT gate - should create entanglement from superposition [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CNOT gate - should be self-inverse [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get basis state probability - should reject invalid index [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply cost layer - should reject mismatched array length [1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioBuilderTests.Portfolio.solve should return allocations with positive returns [149 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.sampleQuasiProb should preserve sign information [14 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Two-qubit gates - should reject invalid indices [2 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioBuilderTests.Portfolio.solve should accept custom configuration [1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Pauli matrices - should satisfy algebraic properties [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioBuilderTests.Portfolio.solve should handle 5 assets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Run QAOA circuit - should reject mismatched array lengths [1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioBuilderTests.Portfolio.createProblem should create problem from 3 assets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Hadamard gate - should create superposition correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Compute cost expectation - should handle negative coefficients [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply mixer layer - should preserve norm [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Compute cost expectation - should calculate correctly for basis states [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Run QAOA circuit - should apply multiple layers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioBuilderTests.Portfolio.solveDirectly should solve without creating problem explicitly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get qubit probabilities - should handle entangled states [3 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.applyStrategy should succeed with primary strategy [11 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Rx gate - should rotate around X axis correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CZ gate - should be self-inverse [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Initialize uniform superposition - should create equal amplitudes [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioBuilderTests.Portfolio.solve should respect budget constraint [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Pauli-Z gate - should apply phase flip correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Medium circuit (45 gates) with budget should select ZNE + Readout with fallback [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioBuilderTests.Portfolio.solve should return valid allocation for 3 assets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Pauli-X gate - should flip qubit basis states correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Cost estimation should match strategy selection [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Collapse after measurement - should preserve norm [1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Rotation gates - should handle special angles correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Rz gate - should rotate around Z axis correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply cost interaction - should reject invalid indices [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply cost interaction - should apply ZZ interaction [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Shallow circuit (9 gates) should select Readout-only [1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CZ gate - should add phase when both qubits are 1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CZ gate - should be symmetric [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Initialize uniform superposition - should reject invalid qubit counts [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Strategy with fallback should provide secondary option [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaSimulatorTests.Apply mixer layer - should apply Rx rotations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Gate composition - should apply gates in correct order [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Collapse after measurement - should reject invalid inputs [2 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CZ gate - should preserve norm [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Default strategy (no constraints) should be balanced [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output CNOT gate correctly [20 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaCircuitTests.QAOA circuit should serialize to OpenQASM format [156 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Gate application - should preserve state vector norm [5 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output Z gate correctly [5 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Very low budget ($0.50) should select Readout-only [5 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.CNOT gate - should preserve norm [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Empty circuit should have correct qubit count [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Low budget ($5) should select Readout-only [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GatesTests.Multi-qubit gate application - should apply to correct qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Shallow circuit (5 gates) should select Readout-only [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.Deep circuit (60 gates) should select ZNE + Readout [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Sample and count - should approximate probabilities [8 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator should reset after triggering [29 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.validate should fail for CNOT with same control and target [2 ms]
  Passed FSharp.Azure.Quantum.Tests.ErrorMitigationStrategyTests.High accuracy requirement (92%) with budget should select full mitigation stack [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Measure computational basis - should respect probabilities [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate RY should have correct qubit and angle [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Empty circuit should have zero gates [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate RZ should have correct qubit and angle [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output RX gate correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.sampleQuasiProb should sample according to absolute probabilities [20 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output Y gate correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator should trigger on max batch size [5 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Execute detects qubit mismatch [5 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchConfig with negative timeout should fail [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Recommendation should include confidence level [172 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.optimize should remove consecutive H gates on same qubit [1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get top outcomes - should handle n larger than dimension [5 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate Z should have correct qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Measure single qubit - should return 0 or 1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.sampleQuasiProb should work with single-qubit decomposition [2 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaCircuitTests.Mixer Hamiltonian should create X operators for all qubits [16 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get top outcomes - should return sorted by probability [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Collapse after measurement - should zero inconsistent amplitudes [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.PECResult should track corrected expectation and overhead [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Sample and count - should produce frequency distribution [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaCircuitTests.Problem Hamiltonian should construct from 2x2 QUBO matrix [1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Mean-variance should handle 50 assets efficiently [174 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get qubit probabilities - should compute marginals correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get probability distribution - should sum to 1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaCircuitTests.QAOA layer should construct cost and mixer gates [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.validate should pass for valid circuit [2 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.compose should combine two circuits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaCircuitTests.Problem Hamiltonian should handle diagonal QUBO terms [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.PECConfig should specify noise model and sampling parameters [2 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeTwoQubitGate should have correct normalization [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate RX should have correct qubit and angle [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Compute expected value - should calculate correctly [1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Mean-variance optimization with high risk tolerance should favor high returns [2 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Get basis state probability - should compute correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Amplitude amplification works with 1-qubit system [5 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.validate should fail for CNOT with out of bounds target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Medium TSP problem (15 cities) should recommend classical solver [4 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaCircuitTests.Complete QAOA circuit should have initial state and multiple layers [1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Sample measurements - should return correct number of samples [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.sampleQuasiProb should be deterministic with same seed [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output complete circuit correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Recommendation should include human-readable reasoning [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeSingleQubitGate should produce 5-term decomposition [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.addGate should add a single gate to circuit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output X gate correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Invalid input (empty matrix) should return error [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.validate should fail for CNOT with out of bounds control [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.ExecuteWithCustomPreparation runs without error [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Invalid input (null matrix) should return error [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.optimize should preserve gates on different qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Sample measurements - should reject invalid sample count [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Small TSP problem (5 cities) should recommend classical solver [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.addGate should preserve existing gates [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output H gate correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.validate should fail for qubit index out of bounds [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Portfolio solver should validate budget constraint [2 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Large TSP problem (30 cities) should consider quantum solver [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate H should have correct qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.optimize should handle complex optimization scenarios [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.validate should fail for negative qubit index [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.MeasurementTests.Compute standard deviation - should calculate correctly [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate CNOT should have correct control and target qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output RY gate correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumAdvisorTests.Very large TSP problem (100 cities) should strongly recommend quantum solver [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.addGates should add multiple gates at once [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Greedy-by-ratio should allocate assets by return-risk ratio [2 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.Gate Y should have correct qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.validate should collect multiple errors [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.getGates should return gates in order [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should include header and qubit declaration [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Mean-variance optimization should balance return and risk [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.optimize should fuse consecutive RX gates on same qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.optimize should remove consecutive X gates on same qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitBuilderTests.toOpenQASM should output RZ gate correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Tensor product - should compute correct product state [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.State vector equality - should compare states correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Create custom state vector - should create with provided amplitudes [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Initialize state vector - should enforce qubit limits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Probability of basis state - should calculate correct measurement probabilities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Inner product - should calculate correct inner product [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.executeBatch with disabled batching should still execute circuits [13 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Initialize state vector - should create |0⟩^⊗n state correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.State vector norm - should calculate correct norm [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator with size 1 should trigger immediately [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Grover equivalence for multiple targets [8 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Get amplitude - should validate index bounds [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Execute validates configuration [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchConfig with zero batch size should fail [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.StateVectorTests.Normalize state vector - should properly normalize arbitrary states [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Greedy-by-ratio should handle 50 assets efficiently [4 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.OptimalIterations with perfect initial success returns zero [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Rigetti execution time estimation - includes all gates [2 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Portfolio solver should handle assets with zero risk [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.W-state preparation creates correct 3-qubit W-state [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Amplitude amplification with partial uniform preparation [1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Search with target 0 works [7 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Execute with zero iterations returns prepared state [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Amplitude amplification works with 5-qubit system [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchSingle with reproducible seed gives consistent results [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.GroverReflection works on uniform superposition [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Grover provides theoretical quadratic speedup [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.OptimalIterations with zero initial success returns Grover formula [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.IonQ cost calculation - two-qubit gates cost more than single-qubit [2 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.GroverAsAmplification creates correct config [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Grover iteration execution returns valid result [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.OptimalIterations calculates correctly for N=1024 M=1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.OptimalIterations calculates correctly for N=256 M=1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.IonQ cost calculation - cost increases with gate count [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Amplitude amplification result contains all fields [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.ExecuteGroverViaAmplification finds target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchEven finds even numbers [1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.OptimalIterations with high initial success returns few iterations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.DivisibleBy oracle marks divisible numbers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Amplitude amplification preserves state norm [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchSingle finds different targets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.compareCosts - returns estimates for all backends [1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.ReflectionAboutState is self-inverse [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.estimateCost - returns error for invalid shot count [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Grover equivalence with different iteration counts [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Partial uniform superposition creates correct state [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AmplitudeAmplificationTests.Grover via amplitude amplification equals standard Grover [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchSingle in 4-qubit space with optimal iterations [1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Oracle marks single target correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Search with maximum value in space works [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Odd oracle marks all odd numbers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Search in 5-qubit space works [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.FastConfig completes quickly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.FindPrimeNumber example works [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.ManualConfig uses specified iterations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchResult contains complete diagnostics [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchMultiple finds one of multiple targets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.HighPrecisionConfig achieves higher success rate [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchWhere finds odd numbers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.OptimalIterations calculates correctly for N=16 M=1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.ClassicalSearch finds correct value [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.TheoreticalSuccessProbability is high at optimal k [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchSingle finds target in 3-qubit space [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Oracle marks multiple targets correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchWhere finds even numbers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Oracle from predicate works [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Search in 1-qubit space works [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.InRange oracle marks numbers in range [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.FindValue42 example works [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.ClassicalSearch returns None when no solution [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.SearchOdd finds odd numbers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Quantum and classical find same solution [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.Even oracle marks all even numbers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.GroverSearchTests.FindInRange example works [3 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should work with multi-gate QAOA-like circuit [31 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should reject matrix with infinity values [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeSingleQubitGate should include Pauli corrections [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should classify TSP problem from distance matrix correctly [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should handle single city TSP edge case [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should reject non-square distance matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Quantum advantage should reject null input [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should reject matrix with NaN values [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should reduce variance with more samples [5 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.NoiseModel should represent depolarizing noise rates [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.sampleQuasiProb should return gate and weight [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TypesTests.JobStatus should handle unknown status as Failed [259 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - DeclareMemory with different size [259 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.TokenManager should acquire token on first request [260 ms]
  Passed FSharp.Azure.Quantum.Tests.PortfolioSolverTests.Portfolio solver should handle edge case with single asset [73 ms]
  Passed FSharp.Azure.Quantum.Tests.TypesTests.JobStatus should parse Executing status [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should estimate TSP search space for larger problem [48 ms]
  Passed FSharp.Azure.Quantum.Tests.TypesTests.JobStatus should parse Cancelled status [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TypesTests.JobStatus should parse Succeeded status [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TypesTests.JobStatus should parse Failed status with error details [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TypesTests.JobStatus should parse Waiting status [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should estimate quantum advantage for large TSP [5 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.NoiseScaling IdentityInsertion should represent insertion rate [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should estimate quantum advantage for small TSP [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should detect asymmetric distance matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.getJobStatusAsync should handle Failed status with error details [83 ms]
========== BATCHING BENCHMARK ==========
=== Cost Dashboard ===
Parameter Sweep: 100 circuits
No cost records to display.
WITHOUT Batching:
  Job Count: 100 jobs (1 per circuit)
  Execution Time: 5 ms
WITH Batching (MaxBatchSize=50):
  Job Count: 2 jobs (50 circuits per job)
  Execution Time: 20 ms
IMPROVEMENT:
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should reject empty distance matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should handle circuits with only identity-like gates [52 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.TokenManager should refresh expired token [8 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should handle very large TSP problem without overflow [1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.isValidGate - two-qubit gate valid if edge exists (reversed) [9 ms]
  Job Count Reduction: 50.0x (100 -> 2 jobs) ?
  Time Savings: -16 ms (-316.8% faster)
========================================
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should reject matrix with negative distances [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should reject null distance matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should estimate quantum advantage for medium TSP [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.QuilGate - TwoQubit gate has gate name, control, and target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Should estimate TSP search space correctly for small problem [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.ComparisonReport can compare classical and quantum results [2 ms]
  Passed FSharp.Azure.Quantum.Tests.ProblemAnalysisTests.Quantum advantage should reject invalid matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.displayCostDashboard handles empty records [79 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.generateRandomCities creates cities with unique positions [1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.getJobStatusAsync should return job status for successful request [4 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.IonQ cost calculation - cost increases with shot count [2 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.Benchmark: Batching reduces job count by 10x for parameter sweeps [87 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.generateRandomAssets creates assets with valid financial parameters [1 ms]
Baseline error: 0.150, PEC error: 0.133, Reduction: 0.8%
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchConfig with negative batch size should fail [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Full validation should pass for valid circuit [13 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - SingleQubitRotation with RY gate [3 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Backend constraint should define IonQ hardware with 11 qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Backend constraint should define IonQ simulator with 29 qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.ThrottlingHandler should parse rate limit headers from responses [131 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.mitigate should demonstrate error reduction [9 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.batchCircuitsAsync with disabled config should return empty results [4 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeTwoQubitGate should have correct probability formula [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Cost tracker - tracks multiple records [6 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.cancelJobAsync should cancel running job [9 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeProgram - GHZ state with 3 qubits [7 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Budget check - denies job exceeding daily limit [1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeProgram - parameterized rotation circuit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.QuilGate - DeclareMemory has name, type, and size [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.isValidGate - two-qubit gate valid if edge exists [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - TwoQubit gate produces 'GATE control target' format [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.recommendCostOptimization returns None when already using cheapest [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Format validation errors should create summary message [9 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Budget check - warns when approaching limit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.mapRigettiError - maps TooManyQubits to InvalidCircuit [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate circuit with qubit count within backend limits should pass [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Budget check - approves job within limits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate circuit exceeding qubit limit should return error [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.findCheapestBackend works with single backend [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.validateProgram - returns Error for invalid two-qubit gate [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.isValidGate - measurement always valid [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - SingleQubitRotation produces 'GATE(angle) qubit' format [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - Measure with different qubit and memory reference [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.IonQ cost breakdown - validates component costs [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.mapRigettiError - maps TopologyError to InvalidCircuit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate circuit with multiple violations should catch all issues [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.isValidGate - single-qubit rotation always valid [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Rigetti cost calculation - time-based pricing [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.mapRigettiError - maps InvalidProgram to InvalidCircuit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.isValidGate - declaration always valid [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate QAOA parameters should pass for matching array lengths [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Quantinuum cost calculation - HQC quota consumption [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeProgram - Bell state produces correct Quil assembly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.isValidGate - two-qubit gate invalid if edge missing [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.validateProgram - returns Error with gate details for multiple invalid gates [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - DeclareMemory produces 'DECLARE name type[size]' format [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Budget check - denies job exceeding per-job limit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should handle Pauli rotation gates [8 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate QAOA parameters should fail for mismatched beta length [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Backend constraints should define circuit depth limits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeSingleQubitGate should work with zero noise [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeSingleQubitGate quasi-probabilities should sum to 1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.IonQ backends should support standard gate set [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate IonQ all-to-all connectivity should always pass [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Backend constraint should define local simulator with 10 qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Backend constraint should define Rigetti Aspen-M-3 with 79 qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.benchmarkClassicalTSP completes for 5 cities [17 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Full validation should collect all errors for invalid circuit [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate circuit within depth limit should pass [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.benchmarkClassicalTSP produces consistent results with repetitions [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate empty circuit should pass all validations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.mitigate should execute full PEC pipeline [4 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate QAOA parameters should fail for mismatched gamma length [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.nearestNeighborTour should produce reasonable tour for line cities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve should respect maxIterations limit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve with 10 cities should complete in under 10ms [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate Rigetti limited connectivity should reject invalid qubit pairs [1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.buildDistanceMatrix should create symmetric matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate circuit exceeding depth limit should return error [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Cost tracker - getSpendingByBackend groups correctly [8 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate circuit with supported gates should pass [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solveWithDistances should work with custom distance matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.nearestNeighborTour should start from city 0 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.calculateTourLength should sum all edge distances [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.IonQ cost calculation - without error mitigation is cheaper [1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve without nearest neighbor should still work [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.nearestNeighborTour should visit all cities exactly once [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve with circle cities should find near-optimal tour [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve with small TSP should find optimal solution [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve with 20 cities should complete in under 50ms [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Format validation error should provide clear actionable message [2 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.twoOptImprove should improve tour quality [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve with 5 cities should find reasonable solution quickly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.euclideanDistance should calculate correct distance [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CircuitValidatorTests.Validate circuit with unsupported gates should return errors [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspSolverTests.solve with 50 cities should complete in under 1 second [< 1 ms]
=== Cost Dashboard ===
  Passed FSharp.Azure.Quantum.Tests.TspBuilderTests.TSP.solve should return valid tour for 3 cities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspBuilderTests.TSP.solve should accept custom configuration [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspBuilderTests.TSP.solve should handle 5 cities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.mitigate should handle executor failures gracefully [6 ms]
  Passed FSharp.Azure.Quantum.Tests.TspBuilderTests.TSP.solve should return tour with all unique cities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspBuilderTests.TSP.createProblem should create problem from 3 cities with coordinates [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspBuilderTests.TSP.solveDirectly should solve without creating problem explicitly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeTwoQubitGate should include all Pauli basis terms [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.TspBuilderTests.TSP.createProblem should calculate correct distance matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.recommendCostOptimization suggests cheaper backend [4 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.OneHot constraint penalty enforces exactly-one-active rule [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Forcing quantum without config should return error [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.findCheapestBackend returns error for empty backend list [< 1 ms]
?? Today: $80.00 (2 jobs)
?? This Month: $80.00 (2 jobs)
?? Total: $80.00 (2 jobs)
?? Spending by Backend:
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Rigetti cost calculation - cost scales with execution time [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Categorical variable decoding - one-hot to category index [2 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Constraint penalty weight scaling [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.tuneAdaptive should stop when valid solution found [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateConstraints should detect OneHot violation - no bits set [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Large TSP problem should consider quantum (but use classical for now) [3 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Forcing quantum method should return error [< 1 ms]
  IonQ (without error mitigation): $52.00 (1 jobs)
  Rigetti: $28.00 (1 jobs)
?? Estimate Accuracy: 5.5% average error
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.SolutionComparison type should capture quantum vs classical results [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateTransformation should verify QUBO matrix symmetry [1 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.QuantumExecutionConfig should support IonQ backend selection [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.OneHot encoding - Color choice (unordered categories) [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Small Portfolio problem should route to classical solver [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.displayCostDashboard shows spending summary [5 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Budget check - denies job exceeding monthly limit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.IonQ cost calculation - simple circuit with error mitigation [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Forcing classical method should override advisor recommendation [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.compareCosts - handles empty backend list [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Small TSP problem should route to classical solver [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Cost tracker - adds record and updates spending [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Cost tracker - creates empty tracker [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.recommendCostOptimization provides detailed reasoning [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Property: Hard constraint penalty always exceeds objective maximum [2 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Cost tracker - uses estimated cost when actual cost unavailable [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty TSP example - 20 cities with max distance 500km [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Portfolio CorrelationBased should integrate returns on diagonal [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Quantum routing should respect cost limits [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateConstraints should accept valid Binary solution [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.findCheapestBackend returns backend with lowest cost [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Quantinuum HQC calculation - two-qubit gates weighted more heavily [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Quantinuum HQC calculation - minimum cost enforced [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.IonQ cost calculation - warning for high-cost jobs [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostEstimationTests.Quantinuum HQC calculation - increases with circuit complexity [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.exportToCSV creates valid CSV output [19 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Mixed variables - binary and integer encoding [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty Hard constraint should use Lucas Rule [3 ms]
  Passed FSharp.Azure.Quantum.Tests.HybridSolverTests.Large TSP problem with quantum config should route to quantum (mock test) [6 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.benchmarkClassicalTSP execution time increases with problem size [5 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.TSP EdgeBased encoding should encode distances on diagonal [1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.BenchmarkConfig can be created with problem sizes [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Portfolio optimization - 5 assets with priority levels [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC overhead should scale with sample count [18 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Property: Penalty scales monotonically with problem size [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Portfolio Classical - Zero budget should return empty allocation [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.VariableEncoding OneHot should calculate N qubits for N options [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty Lucas Rule ensures constraint dominates objective [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Integer variable encoding - should use one-hot encoding [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Portfolio Quantum - 10-asset portfolio with emulator [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.BoundedInteger roundtrip - All values in range [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Budget Enforcement - Should respect cost limits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Portfolio CorrelationBased QUBO should be symmetric [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateTransformation should pass for TSP edge-based QUBO [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty Hard vs Soft comparison [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.HybridSolver - Large TSP should consider quantum recommendation [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateTransformation should check coefficient bounds [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.TSP Quantum - 5-city problem with emulator should produce valid tour [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Budget Enforcement - Portfolio should handle insufficient budget gracefully [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Complex problem - TSP with 3 cities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Error Handling - Empty TSP input should handle gracefully [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Solution decoding - binary string to variable assignments [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Error Handling - Invalid constraints in Portfolio should handle gracefully [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.TSP EdgeBased encoding should create QUBO from distance matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.BoundedInteger encoding - Order quantity (0-10 units) [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Integration - TSP and Portfolio workflows end-to-end [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Portfolio CorrelationBased encoding should create QUBO from covariance [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Error Handling - HybridSolver with invalid input returns error [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Integer constraint penalty - exactly one bit must be set [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.HybridSolver - Small Portfolio should route to classical automatically [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Error Handling - Portfolio with single asset should allocate within budget [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Error Handling - TSP with single city should return valid trivial tour [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.Portfolio Classical - 20-asset portfolio should satisfy constraints [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.HybridSolver - Small TSP should route to classical automatically [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.TSP Classical - Should produce better than naive tour [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Strategy selection helper - recommend NodeBased for large TSP [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty Portfolio example - soft constraint at 30 percent [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IntegrationTests.TSP Classical - 10-city problem should produce valid tour [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.EncodingStrategy NodeBased should create n-squared variables for TSP [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.TSP EdgeBased encoding should exclude self-loops [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Portfolio CorrelationBased should balance return vs risk [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.VariableEncoding Binary should calculate 1 qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty should handle small problems [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.mitigate should work with multi-gate circuit [7 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.DomainWall encoding - Priority levels (Low < Medium < High < Critical) [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Binary variable encoding - two variables should create 2x2 QUBO [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeSingleQubitGate should have correct probability formula [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty multiple soft weights [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Portfolio CorrelationBased should integrate risk on off-diagonal [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.tuneAdaptive should start with initial penalty [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Constraint penalty - equality constraint [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateTransformation should check for NaN values [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.TSP EdgeBased encoding should apply constraint penalties [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateConstraints should detect OneHot violation - multiple bits set [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.BoundedInteger constraint penalty enforces value bounds [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.tuneAdaptive should increase penalty on violations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Categorical variable encoding - should use one-hot encoding [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateTransformation should verify size consistency [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty Soft constraint should use preference weight [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateTransformation should pass for Portfolio QUBO [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Benchmark EdgeBased vs NodeBased TSP encoding efficiency [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.OneHot encoding - Delivery route selection (3 routes) [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Integer variable decoding - one-hot to integer value [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty should handle large problems [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Strategy selection helper - recommend EdgeBased for small TSP [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Binary encoding - Portfolio asset inclusion decision [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.DomainWall encoding - Qubit efficiency vs OneHot [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.OneHot constraint penalty - Verify QUBO math [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Binary variable encoding - single variable should create identity QUBO [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.EncodingStrategy EdgeBased should create n-squared variables for TSP [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty should handle zero objective max [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.BoundedInteger encoding - Large range efficiency [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.exportMarkdownReport creates file with markdown content [20 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.generateMarkdownReport creates valid markdown with headers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.benchmarkClassicalPortfolio completes for 5 assets [4 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.mitigate should be deterministic with same seed [18 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Custom problem registration - register and apply custom transformation [11 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.VariableEncoding BoundedInteger should calculate log2 qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.runTSPBenchmarkSuite executes benchmarks for multiple problem sizes [2 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.Classical Portfolio benchmark meets performance target for 10 assets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should track error reduction metric [2 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.checkPerformanceRegression detects slowdowns [2 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateTransformation should detect asymmetric QUBO [3 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateConstraints should accept valid OneHot solution [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.validateConstraints should detect BoundedInteger out of range [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Binary and DomainWall encodings have no constraint penalties [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Strategy selection helper - recommend CorrelationBased for Portfolio [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.Property: Soft constraint penalty is always less than hard penalty [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.tuneAdaptive should respect max iterations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.VariableEncoding DomainWall should calculate N-1 qubits for N levels [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuboEncodingTests.ConstraintPenalty should scale with problem size [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should mitigate single-qubit gate errors [5 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeSingleQubitGate should have correct normalization [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.sampleQuasiProb should handle all positive probabilities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.runPortfolioBenchmarkSuite executes benchmarks for multiple problem sizes [4 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeTwoQubitGate should work with zero noise [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.BenchmarkResult can be created with timing data [1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.Classical TSP benchmark meets performance target for 10 cities [1 ms]
  Passed FSharp.Azure.Quantum.Tests.PerformanceBenchmarkingTests.benchmarkClassicalPortfolio produces valid expected return [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should be deterministic with same seed [3 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Local backend executes 2-qubit QAOA circuit [369 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Local backend handles depth-2 QAOA circuit [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.AutoExecute rejects large circuits when Azure unavailable [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.parseCostFromMetadata should return None for invalid JSON [99 ms]
Auto-selecting local simulator (circuit size: 2 qubits)
  Passed FSharp.Azure.Quantum.Tests.CostTests.estimateCost should return zero cost for simulator targets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.Integration: PEC should mitigate two-qubit gate errors [15 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.QuasiProbDecomposition should hold terms with negative probabilities [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Local backend produces consistent measurement statistics [2 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.decomposeTwoQubitGate quasi-probabilities should sum to 1 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Local backend rejects circuits with more than 10 qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Local backend rejects negative shots [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.AutoExecute uses local for small circuits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.parseCostFromMetadata should parse estimated cost from JSON [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Local backend rejects zero shots [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.parseCostFromMetadata should handle missing cost fields [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.estimateCost should return error for empty target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Interface-based backend - Local [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.parseCostFromMetadata should return None for null input [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumBackendTests.Execute with Local backend type [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.parseCostFromMetadata should parse actual cost from JSON [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.estimateCost should add warning for high-cost jobs [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ProbabilisticErrorCancellationTests.mitigate should track overhead correctly [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.estimateCost should increase with shot count [1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.parseCostFromMetadata should return None for empty input [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.estimateCost should return non-zero cost for QPU targets [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.CostTests.estimateCost should return error for invalid shot count [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.parseRigettiResults - handles empty histogram [178 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.QuilGate - SingleQubit gate has gate name and qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - TwoQubit gate with different qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.QuilGate - Measure has qubit and memory reference [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.QuilGate - SingleQubitRotation has gate name, angle, and qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeProgram - program without declarations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.ConnectivityGraph - contains set of edges [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.mapRigettiError - maps QuotaExceeded to QuotaExceeded [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - SingleQubit gate on different qubit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.submitJobAsync should return InvalidCredentials on 401 response [189 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.parseRigettiResults - parses histogram from Rigetti response [8 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - SingleQubit gate produces 'GATE qubit' format [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.createJobSubmission - serializes program to Quil text in InputData [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - Measure produces 'MEASURE qubit memoryRef' format [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.validateProgram - returns Ok for valid program [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeGate - SingleQubitRotation with RZ gate [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.isValidGate - single-qubit gate always valid (no connectivity check) [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.serializeProgram - empty program produces only declarations [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.QuilProgram - contains declarations and instructions [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RigettiBackendTests.createJobSubmission - creates valid job submission for Rigetti simulator [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.createJobSubmission - Uses correct circuit format IonQ_V1 [355 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.mapIonQError - TooManyQubits maps to InvalidCircuit with qubit limit message [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.IonQGate - TwoQubit gate has gate name, control, and target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.Complete workflow - submitAndWaitForResultsAsync has correct signature [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.IonQGate - SingleQubit gate has gate name and target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.serializeGate - TwoQubit gate serializes to JSON with gate, control, and target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.parseIonQResult - Parses histogram with bitstring keys and counts [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.mapIonQError - QuotaExceeded maps to QuotaExceeded [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.IonQGate - SingleQubitRotation has gate name, target, and rotation angle [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaOptimizerTests.Optimizer should enforce parameter bounds for QAOA angles [579 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.fitPolynomial should fit quadratic ZNE curve [313 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.serializeCircuit - Bell state circuit serializes correctly [5 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.IonQGate - Measure gate has array of target qubits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QaoaOptimizerTests.Optimizer should converge for simple 2-qubit QAOA problem [2 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.fitPolynomial should fail with insufficient data points [1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.createJobSubmission - Creates correct JobSubmission for IonQ simulator [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.create should initialize observability state with logging only [375 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.serializeGate - SingleQubitRotation serializes to JSON with gate, target, and rotation [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.create should initialize observability state with both logging and tracing [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.serializeCircuit - GHZ state with rotations serializes correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.mapIonQError - Unknown error code maps to UnknownError [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.defaultConfig should provide sensible Rigetti defaults [3 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.mapIonQError - BackendUnavailable maps to ServiceUnavailable [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.parseIonQResult - Handles single outcome result [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.parseIonQResult - Handles uniform superposition (all outcomes equal probability) [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Confidence intervals should widen with smaller sample sizes [448 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.REMConfig should have sensible defaults for production use [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.serializeGate - Measure gate serializes to JSON with measure gate and target array [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.serializeGate - SingleQubit gate serializes to JSON with gate and target [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.mapIonQError - InvalidCircuit maps to InvalidCircuit with error message [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.IonQCircuit - contains qubit count and gate list [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.serializeCircuit - Empty circuit with just measurement [< 1 ms]
[2025-11-27 18:31:08 INF] Cost: Job job-000 on backend Simulator - No cost information available at 11/27/2025 18:31:08 +00:00
[2025-11-27 18:31:08 INF] Cost: Job job-456 on backend Quantinuum - Estimated: $15.00 at 11/27/2025 18:31:08 +00:00
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.correctReadoutErrors should correct perfect measurement (no errors) [1 ms]
  Passed FSharp.Azure.Quantum.Tests.IonQBackendTests.createJobSubmission - Supports different targets (simulator and hardware) [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.invertCalibrationMatrix should invert well-conditioned matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.validateCalibrationMatrix should accept valid 1-qubit matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.CredentialProviders createCliCredential should return AzureCliCredential [321 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.correctReadoutErrors should clip negative counts when configured [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.bitstringToInt should convert binary strings to integers [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.logCostMetrics should log with no cost information [11 ms]
� Benchmark: Parallel execution 2.5x faster (12ms vs theoretical 30ms sequential)
[2025-11-27 18:31:08 ERR] Error: Job submission failed with context [{"Key": "jobId", "Value": "job-123", "$type": "KeyValuePair`2"}, {"Key": "operation", "Value": "SubmitJob", "$type": "KeyValuePair`2"}]
System.Exception: Test exception
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.create with no configuration should use defaults [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.traceQuantumExecution should execute operation without tracing when no activity source [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.logCostMetrics should log with estimated cost only [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.SubmitJobAsync should fail after max retries exceeded [593 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.AuthenticationHandler should fail gracefully when token acquisition fails [5 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.TokenManager should propagate credential errors [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.TokenManager should recover after clearing cache from failed state [1 ms]
[2025-11-27 18:31:08 INF] Cost: Job job-123 on backend IonQ - Estimated: $10.50, Actual: $9.75 at 11/27/2025 18:31:08 +00:00
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.Benchmark parallel execution should be faster than sequential [15 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.SubmitJobAsync should not retry on non-transient errors [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.extrapolateToZeroNoise should return constant term [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.applyNoiseScaling with zero rate should return original circuit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.withPolynomialDegree should override degree [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.AuthenticationHandler should add Authorization Bearer header [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.applyNoiseScaling IdentityInsertion should preserve qubit count [< 1 ms]
� Benchmark: 51.9% error reduction (baseline: 0.150  ZNE: 0.072)
[2025-11-27 18:31:08 INF] Performance: SubmitJob completed in 150.5ms at 11/27/2025 18:31:08 +00:00 with context [{"Key": "backend", "Value": "IonQ", "$type": "KeyValuePair`2"}, {"Key": "jobId", "Value": "job-123", "$type": "KeyValuePair`2"}]
[2025-11-27 18:31:08 INF] Cost: Job job-789 on backend IonQ - Actual: $12.30 at 11/27/2025 18:31:08 +00:00
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.TokenManager ClearCache should force token refresh [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.logErrorWithContext should log error with exception [6 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.logCostMetrics should log with both estimated and actual costs [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.TokenManager should handle network timeout gracefully [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.traceQuantumExecution should handle different tag types [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.initializeTracing should create activity source [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.Benchmark ZNE should demonstrate 30-50 percent error reduction [4 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.NoiseScaling PulseStretching should represent stretch factor [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.GetResultsAsync should retrieve job results after completion [5 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.logPerformanceMetrics should log without exception [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.fitPolynomial should handle linear fit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.logCostMetrics should log with actual cost only [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.fluent API should compose beautifully [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.defaultConfig should provide sensible IonQ defaults [< 1 ms]
[2025-11-27 18:31:08 ERR] Error: Rate limit exceeded with context [{"Key": "jobId", "Value": "job-456", "$type": "KeyValuePair`2"}]
� Benchmark: 3x overhead (3 circuit executions for 3 noise levels)
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.mitigate should demonstrate error reduction [2 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.withNoiseScalings should override noise levels [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.initializeLogging with file sink should create logger [5 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.create should initialize observability state with tracing only [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.mitigate should handle executor failures gracefully [2 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.traceQuantumExecution should execute operation with tracing when activity source exists [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.extrapolateToZeroNoise with empty coefficients should return zero [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.logErrorWithContext should log error without exception [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.applyNoiseScaling IdentityInsertion should increase circuit depth [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.initializeLogging should respect minimum log level [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.initializeTracing with console export should create activity source [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ObservabilityTests.initializeLogging should create logger with default configuration [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.Benchmark ZNE overhead should be 3x circuit executions [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.applyNoiseScaling PulseStretching should preserve circuit structure [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.mitigate should compose all ZNE steps [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Integration: 3-qubit REM should demonstrate error reduction [26 ms]
  Passed FSharp.Azure.Quantum.Tests.ZeroNoiseExtrapolationTests.mitigate with single noise level should still work [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Confidence intervals should be non-negative [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.invertCalibrationMatrix should warn on poorly-conditioned matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.correctReadoutErrors should filter noise below threshold [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.CredentialProviders createDefaultCredential should return DefaultAzureCredential [23 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Integration: 2-qubit REM should reduce errors [8 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.TokenManager should cache token on subsequent requests [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.AuthenticationTests.CredentialProviders createManagedIdentityCredential should return ManagedIdentityCredential [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.correctReadoutErrors should provide confidence intervals for all states [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Fluent API should allow chaining configuration [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.validateCalibrationMatrix should reject probabilities outside [0,1] [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Integration: 3-qubit calibration should work [3 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.correctReadoutErrors should normalize probabilities to sum to 1.0 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.correctReadoutErrors should improve biased measurement [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.withConfidenceLevel should override confidence level [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Integration: 2-qubit calibration should work [3 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator concurrent Add and TryFlush should not lose items [370 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchMetrics should track total circuits processed [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchConfig with zero timeout should fail [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.End-to-end: Batch multiple circuits with metrics tracking [1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.Benchmark: Batching overhead is minimal for small circuit counts [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Integration: 1-qubit calibration should measure correct confusion matrix [15 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.withClipNegative should toggle negative clipping [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.WaitForCompletionAsync should poll until job succeeds [57 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.WaitForCompletionAsync should return error when job fails [1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.Integration: 1-qubit REM should reduce readout errors [11 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.validateCalibrationMatrix should reject columns not summing to 1.0 [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.invertCalibrationMatrix should reject nearly singular matrix [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.ReadoutErrorMitigationTests.validateCalibrationMatrix should reject matrix with invalid dimensions [1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator should not trigger before timeout [53 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.batchCircuitsAsync with single circuit should return single result [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchMetrics should calculate batch efficiency [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.WaitForCompletionAsync should timeout if job takes too long [105 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.GetJobStatusAsync returns full job details including execution times [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.CancelJobAsync should send POST to cancel endpoint [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.GetJobStatusAsync should send GET request and parse response [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.GetJobStatusAsync should handle 404 error [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.SubmitJobAsync should retry on transient errors and succeed [56 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.SubmitJobAsync should send PUT request to correct endpoint [1 ms]
  Passed FSharp.Azure.Quantum.Tests.QuantumClientTests.GetResultsAsync should return error for incomplete job [1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator should trigger on timeout with partial batch [157 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.batchCircuitsAsync should preserve circuit order in results [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator timeout should reset after batch submission [61 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchConfig default should have sensible values [1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.batchCircuitsAsync should batch multiple circuits based on size limit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchConfig with valid parameters should succeed [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator should accumulate items below max size [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchMetrics should track total execution time [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.batchCircuitsAsync should handle batch submission errors gracefully [1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.batchCircuitsAsync with empty list should return empty results [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.executeBatch should return error if any circuit fails [1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.executeBatch with Local backend should execute multiple circuits [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchAccumulator should maintain batch size limit under concurrent load [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.BatchAccumulatorTests.BatchMetrics should calculate average batch size [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.ThrottlingHandler should return 429 response when rate limit is exceeded [1 s]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.RateLimiter should track rate limit state across requests [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.calculateExponentialBackoff should return increasing delays [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.RateLimitingTests.RateLimiter shouldThrottle returns true when approaching rate limit [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.pollJobUntilCompleteAsync should poll until job succeeds [6 s]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.submitJobAsync should return job ID on successful submission [1 ms]
[xUnit.net 00:00:09.06]   Finished:    FSharp.Azure.Quantum.Tests
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.pollJobUntilCompleteAsync should timeout after max duration [2 s]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.getJobStatusAsync should parse Succeeded status correctly [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.cancelJobAsync should handle 404 job not found [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.getJobResultAsync should handle 404 blob not found [1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.pollJobUntilCompleteAsync should respect cancellation token [< 1 ms]
  Passed FSharp.Azure.Quantum.Tests.JobLifecycleTests.getJobResultAsync should download result from blob storage [1 ms]

Test Run Successful.
Total tests: 704
     Passed: 704
 Total time: 9.7489 Seconds
     3>Done Building Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\tests\FSharp.Azure.Quantum.Tests\FSharp.Azure.Quantum.Tests.fsproj" (VSTest target(s)).
     1>Done Building Project "C:\git\FSharp.Azure.Quantum\blue\git\FSharp.Azure.Quantum\FSharp.Azure.Quantum.sln" (VSTest target(s)).

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:11.43
